###########################################
#  1. 투포인터
#  2. 정렬되어 있는 두 리스트의 합집합
#  3. 접두사 합을 활용한 구간 합 계산 소스코드
#  4. 에라토스테네스의 체 이용한 소수 구하기

###########################################



#################################
#            투포인터            #
#################################

n = 5    # 길이
m = 5    # 찾으려고 하는 부분합
data = [1,2,3,2,5]

count = 0    # 수
interval_sum = 0   # 부분합
end = 0  # end 포인터 위치

for start in range(n):

    while interval_sum<m and start<n:   # 작으면 end 옮기고 같거나 크면 start 옮긴다
        interval_sum += data[end]
        end+=1

    if interval_sum ==m:                # 찾는 부분합과 같을 경우 count 증가
        count+=1

    interval_sum-=data[start]           # start가 가르키는 값을 빼준다

print(count)


#################################
#   정렬되어 있는 두 리스트의 합집합   #
#################################

n, m = 3, 4
a = [1, 3, 5]
b = [2,4,6,8]

result = [0] * (m+n)
i, j, k = 0, 0, 0

while i<n or j<m:

    if j>=m or (i<n and a[i]<b[j]):
        result[k] = a[i]
        i+=1

    else:
        result[k] = b[j]
        j+=1

    k+=1

print(result)


#########################################
#   접두사 합을 활용한 구간 합 계산 소스코드   #
#########################################

n = 5
data = [10, 20, 30, 40, 50]

sum_value = 0
prefix_sum = [0]

for i in data:
    sum_value+=i
    prefix_sum.append(sum_value)

left = 3
right = 4
print(prefix_sum[right]-prefix_sum[left-1])


#########################################
#   에라토스테네스의 체 이용한 소수 구하기    #
#########################################

import math
m, n = map(int, input().split())
array = [True for i in range(1000001)]
array[1] = 0

for i in range(2, int(math.sqrt(n))+1):
    if array[i] == True:
        j = 2
        while i*j <= n:
            array[i*j] = False
            j+=1

for i in range(m,n+1):
    if array[i]:
        print(i)


#########################################
#   파이썬 int 자료형 데이터의 개수에 따른 메모리 사용량    #
#########################################
#        1000, 약 4KB
#        1000000    약 4MB
#        10000000   약 40MB
#########################################


#########################################
#   파이썬 시간 관련해서   #
#########################################
#     약 1초에 2000만번 여난 수행한다고 하면 무리 없다고 기억
#  데이터의 개수 100만, 시간 제한 1초라고 하면 NlogN 이면 된다
#  Pypy3이 시간이 빨라서 지원된다면 이걸로 제출하는게 유리!
#########################################


#########################################
#   파이썬 시간 관련해서   #
#########################################
#     약 1초에 2000만번 여난 수행한다고 하면 무리 없다고 기억
#  데이터의 개수 100만, 시간 제한 1초라고 하면 NlogN 이면 된다
#  Pypy3이 시간이 빨라서 지원된다면 이걸로 제출하는게 유리!
#########################################


#########################################
#    정렬 시간 복잡도                      #
#########################################
#   퀵정렬 평균적으로 nlogn 이지만 최악의 경우 n제곱임
#   바로 이미 데이터가 정렬되어 있는 경우 매우 느림
#   삽입 정렬은 이미 데이터가 정렬되어 있는 경우 매우 빠름
#   계수 정렬 데이터의 개수 N 데이터 중 최댓값이 K 일 때, 최악의 경우에도 N+K 보장, 하지만 데이터의 크기 범위가 제한되어 정수 형태로 표현 가능할 때만 사용
#########################################


#########################################
#    메모리제이션 기법                     #
#########################################
#   다이나믹 프로그래밍을 구현하는 방법 중 한 종류로
#   한 번 구현 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법
#   메모이제이션은 값을 저장하는 방법이므로 캐싱이라고도 함


#########################################
#    다이나믹 프로그래밍과 분할 정복의 차이점
#########################################
#   다이나믹 프로그래밍들은 문제들이 서로 영향을 미치고 있음
#########################################






